---
title: "Com arreglar l'error \"Maximum call stack exceeded\" d'una funci√≥ recursiva mitjan√ßant iteraci√≥ a JavaScript"
pubDate: 2024-01-05
thumbnail: ~/assets/thumbnails/abstract.jpeg
subtitle: Recur... qu√©?
shortDescription: >
  Explora un enfocament distint per rec√≥rrer un objecte utilitzant iteraci√≥ en lloc de recursi√≥ i aix√≠ evitar l'error de l√≠mit de la pila.
---

import Highlight from '~/components/ui/Highlight.astro';

Un dia a la feina vaig haver de rec√≥rrer una estructura de dades complexa per eliminar algunes refer√®ncies circulars (Contentful CMS i linked entries, us sona?) i em vaig trobar amb aquest error:

```bash
RangeError: Maximum call stack size exceeded (Chrome)
InternalError: too much recursion (Firefox)
RangeError: Maximum call stack size exceeded. (Safari)

# Alguns navegadors s√≥n una mica m√©s humans que altres a l'hora d'anunciar les males not√≠cies üëÄ
```

Estava utilitzant una funci√≥ recursiva fant√†stica per rec√≥rrer aquestes dades i de sobte em vaig donar de cara amb la realitat. Vaig ser copejat per l'error "Maximum call stack exceeded". "Mala tarde". El pitjor de tot √©s que aquest error va comprometre producci√≥ i, com no estavem manejant l'error els nostres usuaris estaven experimentant el que s'anomena en angl√®s la "Black Screen of Death".

<Highlight>Al final d'aquesta entrada aprendr√†s a evitar aquesta situaci√≥ convertint una funci√≥ recursiva en la seva contrapart iterativa</Highlight>. Per√≤ primer us far√© una petita introducci√≥ a l'enfocament recursiu.

## Cr√≤nica d'un desastre anunciat, l'intent recursiu

Com a refer√®ncia, aquesta √©s una versi√≥ simplificada del codi que va provocar tot aquest embolic:

```js title="normalize.js"
function normalizeObject(object) {
  if (Array.isArray(object)) {
    for (const item of object) {
      normalizeObject(item);
    }
  } else if (object !== null && typeof object === 'object') {
    for (const property in object) {
      // Aqu√≠ podem fer comprovacions per veure quines propietats s√≥n candidats a refer√®ncies circulars i les podem eliminar o modificar. Com per exemple:
      // if (object[property]?.sys?.id === 'internalLink') {
      //   delete object[property].page;
      // }
      normalizeObject(object[property]);
    }
  }
}

normalizeObject(complexObject);
```

Aquesta recursivitat funciona de la seg√ºent manera:

1. La funci√≥ pren un `Object` com a par√†metre.

2. Primer comprova si l'objecte √©s un `Array` utilitzant `Array.isArray(object)`. Si √©s cert, itera sobre cada element de la matriu i crida recursivament `normalizeObject` a cada element.

3. En cas contrari, si no √©s `null` i √©s de tipus `Object`, vol dir que √©s un objecte. &mdash;array i null s√≥n de tipus `Object` a JavaScript, per aix√≤ comprovem que no sigui null&mdash; En aquest cas, itera les seves propietats fent servir un bucle `for...in`. Per a cada propietat, fa l'operaci√≥ desitjada i crida recursivament a `normalizeObject` passant el valor de la propietat.

Aquest enfocament va funcionar b√© fins que no va funcionar.

## Ja cal que et calcis, que la cosa es posa interessant

Despr√©s d'algunes investigacions, vaig trobar una opci√≥ de node v8 per incrementar la dimensi√≥ de la pila anomenada `--stack-size`
per√≤ ajustar aquesta opci√≥ no em va semblar b√©. No tinc res en contra d'aquesta opci√≥, si resol
problema hauria d'estar b√©, no √©s aix√≠? Per√≤ aquesta opci√≥ no √©s fiable, tal com es diu a [aquesta incid√®ncia de Github](https://github.com/nodejs/node/issues/6360).

Per tant, tornat al problema, despr√©s d'una estona m√©s d'investigaci√≥ en vaig trobar [aquest article](https://exploringjs.com/es6/ch_tail-calls.html) sobre un concepte anomenat **Tail Call Optimization**

> ECMAScript 6 offers tail call optimization, where you can make some function calls without growing the call stack.

Ei, aix√≤ sembla prometedor... per√≤ segons despr√©s em va donar un cop la realitat un altre cop. ü§Ø

> Warning: Even though tail call optimization is part of the language specification, it isn‚Äôt supported by many engines and that may never change.

Tornant al cas, vaig haver de trobar una alternativa i va ser llavors quan vaig descobrir que una funci√≥ recursiva es podia traduir a una versi√≥ iterativa.

## El nostre vell amic, la iteraci√≥

El concepte per a l'enfocament iteratiu √©s senzill, <Highlight>utilitza una pila o una cua per processar seq√ºencialment elements d'una estructura de dades sense utilitzar la recursivitat</Highlight>.

```js title="normalize.js"
function normalizeObject(object) {
  let queue = [object];

  while (queue.length) {
    const current = queue.shift();

    if (Array.isArray(current)) {
      queue = [...queue, ...current];
    }

    if (current !== null && typeof current === 'object') {
      for (const property in current) {
        // Aqu√≠ podem fer comprovacions per veure quines propietats s√≥n candidats a refer√®ncies circulars i les podem eliminar o modificar. Com per exemple:
        // if (object[property]?.sys?.id === 'internalLink') {
        //   delete object[property].page;
        // }
        queue.push(current[property]);
      }
    }
  }
}

...

normalizeObject(complexObject);
```

Aqu√≠ teniu un desglossament del codi:

1. La funci√≥ pren un `Object` com a par√†metre.

2. Inicialitza una matriu que far√† la funci√≥ de cua i que cont√© un √∫nic element que ser√† l'objecte d'entrada.

3. El codi entra en un bucle `while` que continua mentre la cua no estigui buida.

4. Dins del bucle, treim de la cua el primer element (actual).

5. Si l'element actual √©s de tipus `Array`, els seus elements s'afegeixen a la cua.

6. Si l'element actual √©s de tipus `Object` (i no null), itera les seves propietats utilitzant un bucle `for...in`.

7. Per a cada propietat, fa els canvis necessaris i despr√©s col¬∑loca el valor de la propietat a la cua.

8. El proc√©s continua fins que la cua estigui buida.

Convertir la funci√≥ recursiva a aquesta versi√≥ iterativa va solucionar l'error del l√≠mit de pila. Pentura hi ha altres alternatives que encara no he descobert, per√≤ aquesta soluci√≥ ens
va funcionar b√© al seu moment.

Resumint, a aquesta entrada hem vist que la recursivitat pot generar un error si els objectes
s√≥n massa complexos i la pila de cridades de la recursivitat creix massa. Hem vist i analitzat un exemple real d'una funci√≥ recursiva que pot causar aquest error. Despr√©s hem vist com s'analitza un problema d'aquest tipus i quines barreres ens hem anat trobant, des de descobrir "Tail Call Optimization" i donar-nos conta que no tots els motors de navegadors ho suporten fins a descobrir que pod√≠em substituir la recursivitat amb un equivalent iteratiu que finalment solucionava el nostre problema.

No obstant aix√≤, aneu amb compte i analitzeu sempre el vostre problema perqu√®, per a nosaltres, la versi√≥ iterativa de vegades era m√©s lenta que la recursiva, depenent de les operacions fetes a l'interior i d'altres factors que no entenc del tot.

Per√≤ aix√≤ no importa si la recursivitat genera un error, no √©s aix√≠? üòÑ

## Bonus

Si voleu provar-ho, podeu crear el seg√ºent fitxer:

```js title="recursion-test.js"
const createDeeplyNestedObject = (depth, currentDepth = 0) => {
  if (currentDepth === depth) {
    return 'Reached maximum depth';
  }

  return {
    nestedObject: createDeeplyNestedObject(depth, currentDepth + 1),
  };
};

const iterativeReplacer = (value) => {
  let queue = [value];

  while (queue.length) {
    const current = queue.shift();

    if (Array.isArray(current)) {
      queue = [...queue, ...current];
    } else if (current !== null && typeof current === 'object') {
      for (const property in current) {
        queue.push(current[property]);
      }
    }
  }
};

const recursiveReplacer = (value) => {
  if (Array.isArray(value)) {
    for (const item of value) {
      recursiveReplacer(item);
    }
  } else if (value !== null && typeof value === 'object') {
    for (const property in value) {
      recursiveReplacer(value[property]);
    }
  }
};

(() => {
  /**
   * He ajustat manualment la profunditat d'aquest objecte per evitar precisament l'error "Max Call Stack Size" del que hem xerrat.
   *
   * Ajustau la profunditat per a diferents resultats.
   */
  const deeplyNestedObject = createDeeplyNestedObject(6000);

  const startRecursive = performance.now();

  try {
    recursiveReplacer(deeplyNestedObject);

    console.log('\x1b[32m%s\x1b[0m', 'Recursive function succeed');
  } catch (e) {
    console.log('\x1b[31m%s\x1b[0m', 'Recursive function failed');
  } finally {
    const endRecursive = performance.now();
    const timeSpent = endRecursive - startRecursive;

    console.log(`Time spent processing: ${timeSpent} milliseconds`);
  }

  console.log('-------------');

  const startIterative = performance.now();

  try {
    iterativeReplacer(deeplyNestedObject);

    console.log('\x1b[32m%s\x1b[0m', 'Iterative function succeed');
  } catch (e) {
    console.log('\x1b[31m%s\x1b[0m', 'Iterative function failed');
  } finally {
    const endIterative = performance.now();
    const timeSpent = endIterative - startIterative;

    console.log(`Time spent processing: ${timeSpent} milliseconds`);
  }
})();
```

L'execuci√≥ d'aquest fitxer donar√† el resultat seg√ºent:

```bash
node recursion-test.js

Recursive function failed
Time spent processing: 5.062059998512268 milliseconds
-------------
Iterative function succeed
Time spent processing: 4.321290999650955 milliseconds
```
