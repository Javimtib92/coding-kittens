---
title: "C贸mo arreglar el error \"Maximum call stack exceeded\" de una funci贸n recursiva mediante iteraci贸n en JavaScript"
pubDate: 2024-01-05
thumbnail: ~/assets/thumbnails/abstract.jpeg
subtitle: Recur... 驴qu茅?
shortDescription: >
  Explora un enfoque distinto para recorrer un objeto utilizando iteraci贸n en lugar de recursi贸n y as铆 evitar el error de l铆mite de la pila.
---

import Highlight from '~/components/ui/Highlight.astro';

Un d铆a en el trabajo tuve que recorrer una estructura de datos compleja para eliminar algunas referencias circulares (Contentful CMS y linked entries, 驴os suena?) y me encontr茅 con este error:

```bash
RangeError: Maximum call stack size exceeded (Chrome)
InternalError: too much recursion (Firefox)
RangeError: Maximum call stack size exceeded. (Safari)

# Algunos navegadores son algo m谩s humanos que otros a la hora de anunciar las malas noticias 
```

Estaba utilizando una funci贸n recursiva fant谩stica para recorrer estos datos, y de repente me di de bruces con la realidad. Fui golpeado por el error "Maximum call stack exceeded". Mala tarde. Lo peor de todo es que este error comprometi贸 producci贸n y, como no est谩bamos manejando el error, nuestros usuarios estaban experimentando lo que se llama en ingl茅s la "Black Screen of Death".

<Highlight>Al final de esta entrada aprender谩s a evitar esta situaci贸n convirtiendo una funci贸n recursiva en su contraparte iterativa</Highlight>. Pero primero os har茅 una peque帽a introducci贸n al enfoque recursivo.

## Cr贸nica de un desastre anunciado, el intento recursivo

Como referencia, esta es una versi贸n simplificada del c贸digo que provoc贸 todo este l铆o:

```js title="normalize.js"
function normalizeObject(object) {
  if (Array.isArray(object)) {
    for (const item of object) {
      normalizeObject(item);
    }
  } else if (object !== null && typeof object === 'object') {
    for (const property in object) {
      // Aqu铆 podemos realizar comprobaciones para ver qu茅 propiedades son candidatas a referencias circulares y as铆 modificarlas o eliminarlas. C贸mo por ejemplo:
      // if (object[property]?.sys?.id === 'internalLink') {
      //   delete object[property].page;
      // }
      normalizeObject(object[property]);
    }
  }
}

normalizeObject(complexObject);
```

Esta recursividad funciona de la siguiente forma:

1. La funci贸n toma un `Object` como par谩metro.

2. Primero comprueba si el objeto es un `Array` utilizando `Array.isArray(object)`. Si es as铆, itera sobre cada elemento de la matriz y llama recursivamente `normalizeObject` sobre cada elemento.

3. En caso contrario, si no es `null` y es de tipo `Object`, significa que es un objeto. &mdash;array y null son de tipo `Object` en Javascript, por eso comprobamos que no sea null&mdash; En este caso, itera sus propiedades utilizando un bucle `for...in`. Para cada propiedad, realiza la operaci贸n deseada y llama recursivamente a `normalizeObject` pasando el valor de la propiedad.

Este enfoque funcion贸 bien hasta que no funcion贸.

## Ag谩rrate, que vienen curvas

Despu茅s de algunas investigaciones, encontr茅 una opci贸n de node v8 para incrementar el tama帽o de la pila llamada `--stack-size`
pero ajustar esa opci贸n no me pareci贸 bien. No tengo nada en contra de esta opci贸n, si resuelve el
problema deber铆a estar bien, 驴no es as铆? Pero esta opci贸n no es fiable, tal y como se dice en [esta incidencia de Github](https://github.com/nodejs/node/issues/6360).

Por lo tanto, de vuelta al problema, despu茅s de un rato m谩s de investigaci贸n, me encontr茅 con [este art铆culo](https://exploringjs.com/es6/ch_tail-calls.html) sobre un concepto llamado **Tail Call Optimization**

> ECMAScript 6 offers tail call optimization, where you can make some function calls without growing the call stack.

Eh, esto parece prometedor... pero segundos despu茅s me di con la realidad otra vez. く

> Warning: Even though tail call optimization is part of the language specification, it isnt supported by many engines and that may never change.

Volviendo al caso, tuve que encontrar una alternativa y fue entonces cuando descubr铆 que una funci贸n recursiva pod铆a traducirse a una versi贸n iterativa.

## Nuestra vieja amigo, la iteraci贸n

El concepto para el enfoque iterativo es sencillo, <Highlight>utiliza una pila o una cola para procesar secuencialmente elementos de una estructura de datos sin utilizar la recursividad</Highlight>.

```js title="normalize.js"
function normalizeObject(object) {
  let queue = [object];

  while (queue.length) {
    const current = queue.shift();

    if (Array.isArray(current)) {
      queue = [...queue, ...current];
    }

    if (current !== null && typeof current === 'object') {
      for (const property in current) {
         // Aqu铆 podemos realizar comprobaciones para ver qu茅 propiedades son candidatas a referencias circulares y as铆 modificarlas o eliminarlas. C贸mo por ejemplo:
        // if (object[property]?.sys?.id === 'internalLink') {
        //   delete object[property].page;
        // }
        queue.push(current[property]);
      }
    }
  }
}

...

normalizeObject(complexObject);
```

Aqu铆 ten茅is un desglose del c贸digo:

1. La funci贸n toma un `Object` como par谩metro.

2. Inicializa una matriz que har谩 la funci贸n de cola y que contiene un 煤nico elemento que ser谩 el objeto de entrada.

3. El c贸digo entra en un bucle `while` que sigue mientras la cola no est茅 vac铆a.

4. Dentro del bucle, sacamos de la cola el primer elemento (actual).

5. Si el elemento actual es de tipo `Array`, sus elementos se a帽aden a la cola.

6. Si el elemento actual es de tipo `Object` (y no null), itera sus propiedades utilizando un bucle `for...in`.

7. Para cada propiedad, realiza los cambios necesarios y despu茅s coloca el valor de la propiedad en la cola.

8. El proceso contin煤a hasta que la cola est茅 vac铆a.

Convertir la funci贸n recursiva a esa versi贸n iterativa solucion贸 el error del l铆mite de pila. Tal vez existen otras alternativas que todav铆a no he descubierto, pero esta soluci贸n nos
funcion贸 bien en su momento.

Resumiendo, en esta entrada hemos visto que la recursividad puede generar un error si los objetos
son demasiado complejos y el mont贸n de llamadas de la recursividad crece demasiado. Hemos visto y analizado un ejemplo real de una funci贸n recursiva que puede causar ese error. Luego hemos visto c贸mo se analiza un problema de este tipo y qu茅 barreras nos hemos ido encontrando, desde descubrir "Tail Call Optimization" y darnos cuenta de que no todos los motores de navegadores lo soportan hasta descubrir que pod铆amos sustituir la recursividad con un equivalente iterativo que finalmente solucionaba nuestro problema.

Sin embargo, ten cuidado y analiza siempre tu problema porque, para nosotros, la versi贸n iterativa a veces era m谩s lenta que la recursiva, dependiendo de las operaciones realizadas en el interior y de otros factores que no entiendo del todo.

Pero esto no importa si la recursividad genera un error, 驴no es as铆? 

## Bonus

Si quieres probarlo, puedes crear el siguiente archivo:

```js title="recursion-test.js"
const createDeeplyNestedObject = (depth, currentDepth = 0) => {
  if (currentDepth === depth) {
    return 'Reached maximum depth';
  }

  return {
    nestedObject: createDeeplyNestedObject(depth, currentDepth + 1),
  };
};

const iterativeReplacer = (value) => {
  let queue = [value];

  while (queue.length) {
    const current = queue.shift();

    if (Array.isArray(current)) {
      queue = [...queue, ...current];
    } else if (current !== null && typeof current === 'object') {
      for (const property in current) {
        queue.push(current[property]);
      }
    }
  }
};

const recursiveReplacer = (value) => {
  if (Array.isArray(value)) {
    for (const item of value) {
      recursiveReplacer(item);
    }
  } else if (value !== null && typeof value === 'object') {
    for (const property in value) {
      recursiveReplacer(value[property]);
    }
  }
};

(() => {
  /**
   * He ajustado manualmente la profundidad de este objeto para evitar precisamente el error "Max Call Stack Size" del que hemos hablado.
   *
   * Ajusta la profundidad para diferentes resultados.
   */
  const deeplyNestedObject = createDeeplyNestedObject(6000);

  const startRecursive = performance.now();

  try {
    recursiveReplacer(deeplyNestedObject);

    console.log('\x1b[32m%s\x1b[0m', 'Recursive function succeed');
  } catch (e) {
    console.log('\x1b[31m%s\x1b[0m', 'Recursive function failed');
  } finally {
    const endRecursive = performance.now();
    const timeSpent = endRecursive - startRecursive;

    console.log(`Time spent processing: ${timeSpent} milliseconds`);
  }

  console.log('-------------');

  const startIterative = performance.now();

  try {
    iterativeReplacer(deeplyNestedObject);

    console.log('\x1b[32m%s\x1b[0m', 'Iterative function succeed');
  } catch (e) {
    console.log('\x1b[31m%s\x1b[0m', 'Iterative function failed');
  } finally {
    const endIterative = performance.now();
    const timeSpent = endIterative - startIterative;

    console.log(`Time spent processing: ${timeSpent} milliseconds`);
  }
})();
```

La ejecuci贸n de este archivo dar谩 el siguiente resultado:

```bash
node recursion-test.js

Recursive function failed
Time spent processing: 5.062059998512268 milliseconds
-------------
Iterative function succeed
Time spent processing: 4.321290999650955 milliseconds
```
