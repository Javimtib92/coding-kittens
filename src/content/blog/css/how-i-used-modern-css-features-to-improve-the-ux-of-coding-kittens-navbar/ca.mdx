---
title: 'Com vaig utilitzar noves functionalitats de CSS para millorar la UX de la barra de navegaci√≥ de Coding Kittens'
pubDate: 2024-01-20
thumbnail: ~/assets/thumbnails/post_2.jpeg
subtitle: 'Si en G√†ndalf program√©s amb CSS seria aix√≠'
shortDescription: >
  Un exemple pr√†ctic de com utilitzar "Scroll-Driven Animations" per millorar la teva web.
---

import Callout from '~/components/ui/Callout.astro';
import Highlight from '~/components/ui/Highlight.astro';
import ImageCard from '~/components/ui/ImageCard.astro';
import Pill from '~/components/Pill.astro';
import { CodeSandbox } from '~/components/react/Sandpack';
import { getFiles } from '~/examples/navigation-shrink';
import cardImage from "~/assets/images/post_2_1.png";

<Callout title='Atenci√≥! Funcionalitat experimental' type='warning'>
  Al moment d'escriure aquesta entrada la funcionalitat de **`animation-timeline:scroll`** encara √©s experimental.
  Assegura't que afegeixes una alternativa compatible. Pots consultar la llista de compatibilitat a [caniuse.com](https://caniuse.com/mdn-css_properties_animation-timeline_scroll)
</Callout>

## Una mica de context

He treballat en moltes iteracions de la barra de navegaci√≥ d'aquesta web per aconseguir un estil el qual em satisf√©s. Volia un logo que destaques i amb una navegaci√≥ sempre visible ‚Äî especialment a m√≤bil ‚Äî perqu√® la persona llegint aquesta entrada pogu√©s interactuar amb ella en tot moment.

Per aquest motiu vaig decidir que la barra de navegaci√≥ s'adher√≠s a la part superior quan l'usuari es desplac√©s i vaig afegir el logo amb el nom de la web i l'esl√≤gan.

Preci√≥s, ‚Äî des del meu punt de vista ‚Äî per fi estava content amb el resultat.

```bash
git commit -m "implement absolute perfect non-AI Navbar"
```

Despr√©s del desplegament autom√†tic, em disposo a consultar al meu m√≤bil com ha quedat la web. Tot pareixia fant√†stic fins que vaig comen√ßar a llegir la meva primera entrada al blog [Com arreglar l'error "Stack-Size limit" d'una funci√≥ recursiva mitjan√ßant iteraci√≥ a JavaScript](/blog/javascript/how-to-fix-stack-size-limit-error-of-a-recursive-function-using-iteration-in-javascript) i em vaig adonar que al meu m√≤bil diminut amb la meva pantalla min√∫scula la barra de navegaci√≥ ocupava gran part de l'espai de lectura.

Llavors tenia un m√≤bil de 4,7 polzades aix√≠ que normalment no tenia molt d'espai per llegir.

Mira.

<ImageCard
  id='image01'
  src={cardImage}
  alt='La web de Coding Kittens amb una barra de navegaci√≥ ocupant un percentatge molt alt de la pantalla'
  width={640}
  height={1142}
  quality={80}
  caption={{
    text: 'La barra de navegaci√≥ ocupa un percentatge molt alt de la pantalla a un dispositiu petit',
  }}
/>

Sent alguna cosa similar a la claustrof√≤bia quan tenc un text contingut a un espai tan diminut.

Tot i aix√≤, no volia que la barra de navegaci√≥ destaques menys <Highlight>‚Äî la primera impressi√≥ quan arrib√©s a una web √©s la m√©s important ‚Äî</Highlight> per√≤ no pod√≠a deixar-ho aix√≠.

Despr√©s vaig pensar... "D'acord, si em molesta quan em despla√ß cap avall per llegir la entrada del blog llavors... qu√® tal si faig que la barra de navegaci√≥ sigui m√©s petita quan l'usuari no √©s a dalt de tot de la p√†gina?".

I aix√≤ √©s el que vaig fer.

D'acord, despr√©s d'aquesta petita introducci√≥ i donat tot el context anem a fer un viatge al m√≥n del CSS i el JavaScript, on l'impossible √©s possible i on hi ha mil maneres d'arribar all√† mateix'. ü™ÑüîÆ

## Implementaci√≥ avorrida

Si fas una recerca r√†pida a google sobre com encollir el men√∫ de navegaci√≥ a mesura que l'usuari es despla√ßa cap avall el primer resultat que et sortir√† segurament ser√† aquesta p√†gina de W3schools: [How TO - Shrink Navigation Menu on Scroll](https://www.w3schools.com/howto/howto_js_navbar_shrink_scroll.asp).

Les seccions d'HTML i CSS s√≥n la base d'una barra de navegaci√≥. La part interessant √©s aquest trosset de JavaScript:

```js
// Quan l'usuari es despla√ßa 80px des de la part de dalt del document, canviam la mida del padding i de la font del logo.
window.onscroll = function () {
  scrollFunction();
};

function scrollFunction() {
  if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
    document.getElementById('navbar').style.padding = '30px 10px';
    document.getElementById('logo').style.fontSize = '25px';
  } else {
    document.getElementById('navbar').style.padding = '80px 10px';
    document.getElementById('logo').style.fontSize = '35px';
  }
}
```

Aquest codi b√†sicament assigna una funci√≥ a l'event global `onscroll` i comprova quina proporci√≥ del `<body>` o del `<html>` l'usuari s'ha despla√ßat. Aplicar√† uns estils o uns altres en funci√≥ de la dist√†ncia.

Aix√≤ √©s tot, gr√†cies per llegir aquesta entrada.

...

...

Ara de deb√≤, aquest intent de solucionar el problema √©s el m√©s simple, i probablement una bona opci√≥ en la majoria dels casos.

El problema √©s que... on est√† la gr√†cia en fer-ho aix√≠? Coding Kittens √©s un lloc on m'agrada experimentar i provar coses noves. <Highlight>Vull una soluci√≥ √≤ptima, extensible i basada exclusivament en CSS</Highlight>

Com et quedaries si et dic que hi ha una manera futurista d'enfocar la soluci√≥ utilitzant exclusivament CSS? Agafaries la <Pill>[#unstyled p√≠ndola avorrida](#implementaci√≥-avorrida)</Pill> o la <Pill color="red">[#unstyled p√≠ndola futur√≠stica](#que-s√≥n-les-funcions-de-css-scroll-i-scrolltimeline)</Pill>?

Si sents curiositat explicar√© a la pr√≤xima secci√≥ una funci√≥ experimental que ens ajudar√† a implementar aquesta funcionalitat. 

La majoria de funcionalitats que farem servir tenen un 96% de suport dels navegadors segons la web [Can I use](https://caniuse.com/). Per altra banda, la funcionalitat important, `animation-timeline:scroll`, √©s menys suportada, per√≤ explicarem com afegir una alternativa per a navegadors que no la suporten.

Aix√≠ doncs, comen√ßarem explicant que √©s `animation-timeline:scroll`.

## Que s√≥n les funcions de CSS Scroll i ScrollTimeline?

Ser√© honest, al moment d'escriure aix√≤ anava a donar una explicaci√≥ detallada de com funciona, per√≤ m'he adonat que tot el que puc dir ja est√† dit com toca a distintes fonts on he trobat aquesta informaci√≥.

- [MDN Web Docs: scroll()](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline/scroll#browser_compatibility)

- [Animate elements on scroll with Scroll-driven animations](https://developer.chrome.com/docs/css-ui/scroll-driven-animations)

- [A case study on scroll-driven animations performance](https://developer.chrome.com/blog/scroll-animation-performance-case-study)

> A Scroll Progress Timeline is an animation timeline that is linked to progress in the scroll position of a scroll container‚Äìalso called scrollport or scroller‚Äìalong a particular axis. It converts a position in a scroll range into a percentage of progress.

Perqu√® ens entenguem, `ScrollTimeline` permet executar una animaci√≥ en funci√≥ de la posici√≥ de despla√ßament actual. Exclusivament amb CSS.

> Integrating scroll-driven animations with two existing APIs, means that they benefit from the advantages of these APIs. That includes the ability to have these animations run off the main thread. Yes, read that correctly: you can now have silky smooth animations, driven by scroll, running off the main thread, with just a few lines of extra code. What's not to like?!

Aix√≤ m'explota el cap ü§Ø

El que vol dir √©s que aquesta animaci√≥ no interromp el fil principal de JavaScript, adeu animacions que petardegen!

Pots comprovar el cas d'estudi que he compartit abans si vols veure una bona comparativa del rendiment entre JavaScript tradicional en comparaci√≥ a `animation-timeline`.

## El m√≥n m√†gic del CSS

Ara, doncs, comencem a fer una mica de m√†gia.

Al seg√ºent exemple he creat una barra de navegaci√≥ similar a la que he creat per la web de Coding Kittens. Comen√ßar√© amb l'HTML b√†sic.

```html title="index.html"
... codi HTML aqu√≠
<nav class="navbar">
  <div class="backdrop"></div>
  <div class="navbar-content">
    <a href="/" class="logo-link">
      <!--Logo SVG -->
      <div class="site-name">
        <p>Your site</p>
      </div>
    </a>
    <div class="navigation-links-container">
      <div class="navigation-links">
        <a>Home</a>
        <a>Blog</a>
      </div>
    </div>
  </div>
</nav>
... m√©s codi HTML aqu√≠
```

Despr√©s, necessitarem afegir alguns estils a aquest element per fer que sigui semblant a una barra de navegaci√≥.

```css title="styles.css"
.navbar {
  display: flex;
  position: sticky;
  padding: 1rem 0.5rem;
  margin-bottom: 3rem;
  margin-top: 5rem;
  flex-direction: row;
  align-items: flex-start;
  top: 0;

  @media (min-width: 768px) {
    padding: 1rem 1.25rem;
  }
}

.backdrop {
  position: absolute;
  top: 0;
  min-width: 100%;
  height: 5rem;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  left: -8px;
  right: -8px;

  @media (min-width: 768px) {
    margin-right: -28px;
    margin-left: -28px;
  }
}

.navbar-content {
  display: flex;
  z-index: 10;
  margin-left: 0;
  flex-direction: row;
  justify-content: space-between;
  min-width: 100%;
}

.logo-link {
  display: flex;
  flex-direction: row;
  align-items: center;
  text-decoration: none;
}

.logo {
  margin-right: 1rem;
}

.site-name {
  display: flex;
  flex-direction: column;
}

.site-name > p {
  color: white;
  margin: 0;
  font-size: 1.5rem;
  line-height: 2rem;
  font-weight: 700;

  @media (min-width: 640px) {
    font-size: 1.5rem;
    line-height: 2rem;
  }
}

.navigation-links-container {
  display: flex;
  flex-direction: row-reverse;
  gap: 1.5rem;

  @media (min-width: 640px) {
    flex-direction: row;
  }
}

.navigation-links {
  display: none;
  flex-direction: row;
  align-items: center;

  @media (min-width: 640px) {
    display: flex;
  }
}

.navigation-links a {
  position: relative;
  padding: 0.25rem 0.5rem;
}
```

Un cop tenguem totes aquestes peces juntes tendrem el seg√ºent:

<CodeSandbox files={getFiles({ animationStyles: false })} client:only="react"/>

Tenim la nostra primera versi√≥ de la barra de navegaci√≥, similar a la mencionada [al principi d'aquesta entrada del blog](#una-mica-de-context). Encara no hem afegit l'animaci√≥ i ocupa un gran percentatge de la pantalla. Ho podem fer millor.

Aplicarem uns quants trucs de m√†gia de CSS ü™Ñ

```css title="styles.css"
  @keyframes shrink { /* [!code focus]*//* [!code ++] */
    0% {/* [!code focus]*//* [!code ++] */
      --navbar-shrink: 0;/* [!code focus]*//* [!code ++] */
    }/* [!code focus]*//* [!code ++] */
    10%,/* [!code focus]*//* [!code ++] */
    100% {/* [!code focus]*//* [!code ++] */
      --navbar-shrink: 1;/* [!code focus]*//* [!code ++] */
    }/* [!code focus]*//* [!code ++] */
  }/* [!code focus]*//* [!code ++] */

.navbar {
    display: flex;
    position: sticky;
    padding: 1rem 0.5rem;
    margin-bottom: 3rem;
    margin-top: 5rem;
    flex-direction: row;
    align-items: flex-start;
    top: 0;
  
    @media (min-width: 768px) {
      padding: 1rem 1.25rem;
    }

    --navbar-shrink: 0; /* [!code focus]*//* [!code ++] */
    animation: shrink; /* [!code focus]*//* [!code ++] */
    animation-timing-function: ease; /* [!code focus]*//* [!code ++] */
    animation-timeline: scroll(nearest block); /* [!code focus]*//* [!code ++] */
}
```

Explicar√© pas per pas que √©s el que esteim fent aqu√≠:

1. Primer definim els `keyframes` de la nostra animaci√≥. Els *keyframes* canviaran una variable de CSS que hem anomenat `--navbar-shrink`. Utilitzarem aquest valor com el nostre valor condicional per alternar entre la navegaci√≥ escur√ßada o normal.

2. Seguidament inicialitzam `--navbar-shrink` a `0`

3. Despr√©s assignam `shrink` a l'animaci√≥

4. Com a *timing function* farem servir `ease`. Per√≤ pots utilitzar el valor que vulguis [d'aquesta llista](https://www.w3schools.com/cssref/css3_pr_animation-timing-function.php) 

5. Finalment definim `animation-timeline` per cridar la funci√≥ de CSS `scroll` amb **nearest** com a `scrollable` i **block** com a `axis`.

<Callout title='Remember' type='warning'>
  **`animation-timeline`** ha de ser declarat despr√©s de la propietat abreviada **`animation`**,
  ja que aquesta reiniciar√† les propietats no incloses i no abreviades al seu valor inicial.
</Callout>

El codi que acabam d'afegir ens permet utilitzar la variable de CSS que utilitzam de condicional per aplicar distints estats a la nostra barra de navegaci√≥ en funci√≥ de la posici√≥ de despla√ßament de l'usuari. Com et quedes? 

Ara afegirem algunes animacions interessants:

```css title="styles.css"
... estils de .navbar ... 

.navbar .navbar-content {
  transition: transform 0.3s ease;
  transform: translateY(calc(0px - var(--navbar-shrink) * 12px));
  /* calc(initial_position - (0 * 12 || 1 * 12))  */
}
.navbar .backdrop {
  transition: transform 0.3s ease;
  transform: translateY(calc(0px - var(--navbar-shrink) * 24px));
  /* calc(initial_position - (0 * 24 || 1 * 24))  */
}

.navbar .logo {
  transition: transform 0.3s ease;
  transform: scale(calc(1 - var(--navbar-shrink) * 0.2));
  /* calc(initial_scale - (0 * 0.2 || 1 * 0.2))  */
}

.navbar p {
  transition: opacity 0.3s ease;
  opacity: calc(1 - var(--navbar-shrink));
  /* calc(initial_opacity - (0 || 1))  */
}
... m√©s estils ...
```

Com es veu utilitzam la variable `--navbar-shrink` per calcular din√†micament el valor utilitzant la funci√≥ de CSS `calc`. Aix√≤ √©s el que est√† fent:

- Moure el *navbar-content* i el *backdrop* uns quants p√≠xels fora de la pantalla.

- Redueix la mida del *logo*

- Redueix l'opacitat del text

Aquest codi es pot estendre per incloure totes les transicions que vulguem.

Fixa't com he fet servir `scale`, `opacity` i `translateY` per [aprofitar l\'animaci√≥ composta](https://web.dev/articles/animations-guide#triggers).

## Alternativa per aquells que utilitzen navegadors antics

Com he mencionat al principi d'aquesta entrada, la propietat de CSS `animation-timeline` encara no est√† suportada a tots els navegadors. De fet, a gener del 2024 dom√©s els navegadors *Chromium* i *Firfeox* (fent √∫s d'una opci√≥ de configuraci√≥ experimental) suporten aquesta propietat.

No tenguis por, tenc la soluci√≥ ideal per tu. Farem alguns canvis al nostre CSS i afegirem una mica de JavaScript.

Comen√ßarem afegint la regla "CSS `@supports`" per comprovar si el navegador suporta la funci√≥ `scroll()`.


```css title="styles.css"
.navbar {
  display: flex;
  position: sticky;
  padding: 1rem 0.5rem;
  margin-bottom: 3rem;
  margin-top: 5rem;
  flex-direction: row;
  align-items: flex-start;
  top: 0;

  @media (min-width: 768px) {
    padding: 1rem 1.25rem;
  } 

   --navbar-shrink: 0;/* [!code --] *//* [!code focus]*/
  /* [!code --] *//* [!code focus]*/
    animation: shrink;/* [!code --] *//* [!code focus]*/
    animation-timeline: scroll(nearest block);/* [!code --] *//* [!code focus]*/
    animation-timing-function: ease;/* [!code --] *//* [!code focus]*/
}

  @supports (animation-timeline: scroll()) {/* [!code ++] *//* [!code focus]*/
    .navbar {/* [!code ++] *//* [!code focus]*/
      --navbar-shrink: 0;/* [!code ++] *//* [!code focus]*/
      /* [!code ++] *//* [!code focus]*/
      animation: shrink;/* [!code ++] *//* [!code focus]*/
      animation-timeline: scroll(nearest block);/* [!code ++] *//* [!code focus]*/
      animation-timing-function: ease;/* [!code ++] *//* [!code focus]*/
    }/* [!code ++] *//* [!code focus]*/
  }/* [!code ++] *//* [!code focus]*/
    
```

A continuaci√≥, si no hi ha suport, necessitam alternar la variable `--navbar-shrink` de totes maneres, ja que encara necessitam canviar els estils de forma din√†mica als elements de la barra de
navegaci√≥.

Afegirem una mica de JavaScript davall el nostre element `nav` perqu√® sigui executat despr√©s que l'element sigui renderitzat a la p√†gina. Idealment, tamb√© es pot afegir just abans del tancament de l'etiqueta `</body>`.

```html title="index.html" {23, 36, 38}
... html code here
<nav class="navbar">
  <div class="backdrop"></div>
  <div class="inner-container">
    <a href="/" class="logo-link">
      <!--Logo SVG -->       
      <div class="site-name">
        <p>Your site</p>
      </div>
    </a>
    <div class="navigation-links">
      <div class="navigation-links-inner">
        <a>Home</a>
        <a>Blog</a>
      </div>
    </div>
  </div>
</nav>
<script>/* [!code focus]*/
  (function () {/* [!code focus]*/
    const navbar = document.querySelector(".navbar");/* [!code focus]*/

    if (!CSS.supports("animation-timeline: scroll()")) {/* [!code focus]*/
      const threshold = 500; // Adjust this threshold as needed/* [!code focus]*/

      window.addEventListener("scroll", handleScroll);/* [!code focus]*/

      function handleScroll() {/* [!code focus]*/
        if (!navbar) {/* [!code focus]*/
          return;/* [!code focus]*/
        }/* [!code focus]*/

        const scrollY = window.scrollY || window.pageYOffset;/* [!code focus]*/

        if (scrollY > threshold) {/* [!code focus]*/
          navbar.style.setProperty("--navbar-shrink", "1");/* [!code focus]*/
        } else {/* [!code focus]*/
          navbar.style.setProperty("--navbar-shrink", "0");/* [!code focus]*/
        }/* [!code focus]*/
      }/* [!code focus]*/
    }/* [!code focus]*/
  })();/* [!code focus]*/
</script>/* [!code focus]*/
... m√©s codi HTML
```

Aquest codi executa la implementaci√≥ que us he mostrat [al principi d'aquesta entrada](#implementaci√≥-avorrida).

Si vols, pots comprovar el resultat dels canvis que hem aplicat al seg√ºent *Code Sandbox*:

<CodeSandbox files={
  getFiles({ animationStyles: true })
} client:only="react"/>

Aix√≤ √©s tot amics! ü•ï

Hem afegit algunes pinzellades de bon gust a la UX per millorar l'experi√®ncia dels usuaris que utilitzen dispositius amb pantalles petites aplicant una animaci√≥ a la barra de navegaci√≥ que te millor rendiment que la variant tradicional, √©s m√©s extensible i dom√©s utilitza CSS. Tamb√© hem afegit una alternativa per aquells usuaris que fan √∫s de navegadors no compatibles.

T'anim a experimentar amb el *Code Sandbox* afegint m√©s *keyframes*, m√©s variables de CSS i en definitiva m√©s variacions.

Esper que haguis gaudit d'aquesta entrada. Fins aviat! üòÑ